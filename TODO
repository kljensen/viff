
VIFF TODO List
==============

There are a number of small and large wanted features listed below. In
addition to those, the source code contains a number of comments
marked with 'TODO' which document things on a more local level. The
features have been roughly divided into design, infrastructure,
benchmarking, and website features.


Design
------

* Define a hierarchy for Runtime functionality
   The Runtime class keeps growing as more and more functionality is
   put into it. An option would be to split it into a basic Runtime
   which provides communication and nothing else. More functionality
   could be provided by mix-in classes. See the discussion here:

     http://thread.gmane.org/gmane.comp.cryptography.viff.devel/61/

* Support preprocessing
   With the use of deferreds, some amount of preprocessing is already
   being done before the protocol begins proper. But this kind of
   preprocessing does nothing for the double auction case where the
   program branches during execution.

   So a general mechanism is needed by which one can preprocess a
   given number of multiplications, comparisons, etc.

   A possible design could be one in which this is done dynamically:
   when a protocol is executed, preprocessed stuff is taken from a
   pool as needed. If the pool runs dry, then more stuff is generated
   online. At the end of a run, the program will know how much stuff
   was needed -- this information can then be dumped to a file.

   A separate preprocessing script can read this information from the
   file and produce another file with a pickled pool of preprocessed
   stuff.

Infrastructure
---------------

* Error handling
   There is currently no error handling in VIFF. Twisted has support
   for defining error callbacks which we should use.

* Replace the marshal module
   The documentation for the marshal module says that:

     Warning: The marshal module is not intended to be secure against
     erroneous or maliciously constructed data. Never unmarshal data
     received from an untrusted or unauthenticated source.

   So when we start dealing with active adversaries, we should replace
   it with something that is secure, probably something that uses the
   struct module. See this discussion for more details:

     http://thread.gmane.org/gmane.comp.cryptography.viff.devel/19

* Use a logging module
   Use a better technique for debug output than scattering print
   statements around the source code.

* Create unit tests which randomizes network delay
   The current unit test with LoopbackRuntime are strictly sequential
   and does not capture the random delays possible with real network
   traffic.

* Allow players to be started in any order
   At the moment one must start players in descending order, 3-2-1,
   but it would be nice if they could be started in any order. Player
   1 would still try and connect to player 2 and 3, but if they cannot
   be reached, then player 1 should retry a bit later.

* More robust handling of port allocation
   Players should check if the wanted port number is free, and if not,
   then retry after a timeout. Ports can be occupied if a player is
   killed, for then the ports normally end up in the TIME_WAIT state
   for 60 seconds.

* Rework port number magic
   Instead of requiring each player to use the correct port number for
   outgoing connections, we could let player 1 act as a coordinator.
   This one player would be required to listen on a well-known port,
   but the other players would not -- they simply listen to some port
   chosen by the OS and announce that to player 1, which in turn let
   the other players know.

   When everybody has been informed of everybody elses presence, the
   protocol execution can begin as normal with pair-wise connections
   between the players. So the coordinator is only used in a setup
   phase and wont become a bottleneck later.

Benchmarking
------------

* Use GMPY per default
   Make field elements use GMPY unless some option asks them not to.

* Benchmark Python vs. GMPY on different key sizes
   Initial tests seems to indicate that the network is the
   bottle-neck, but this should be systematically checked.

* Benchmark constant round multiplication
   The constant round multiplication protocol of Bar-Ilan and Beaver
   from PODC 1989 should be implemented and tested against a standard
   logarithmic round protocol.

* Profile and optimize
   We need to see if the time is spend on network latency or in the
   CPU. If the latter is the case, then we could consider writing the
   inner loop in C for more speed.

Website
-------

* Bug tracker
   It might be convenient to have a place where users can submit bugs.
   But until there is a real demand, the mailing list can be used.

Things we might eventually do
-----------------------------

* Lazy Shamir resharing
   After multiplying two shares, the result is a correct share of the
   product, but a share from a polynomial of degree 2t. We therefore
   normally reshare to get a polynomial of degree t.

   But for doing addition these degree 2t shares are fine, so we could
   wait with the resharing until it is surely needed.
 
   Let [a]_t denote a share of a using a degree t polynomial and let
   [a]_2t -> [a]_t denote a resharing going from degree 2t to t.

   We could then calculate

     sum([a_i]_t * [b_i]_t) = sum([a_i b_i]_2t)
                            = [sum(a_i b_i)]_2t -> [sum(a_i b_i)]_t

   using only one resharing at the end, saving network traffic. There
   does not seem to be many places where we do stuff like that,
   though. So the overhead of keeping track of when resharing is
   needed might be too big for this to be an improvement.


 LocalWords:  VIFF TODO Shamir GMPY wiki BuildBot Epydoc
