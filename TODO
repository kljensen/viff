
VIFF TODO List
==============

There are a number of small and large wanted features listed below. In
addition to those, the source code contains a number of comments
marked with 'TODO' which document things on a more local level. The
features have been roughly divided into design, infrastructure,
benchmarking, and website features.

Infrastructure
---------------

* Error handling
   There is currently no error handling in VIFF. Twisted has support
   for defining error callbacks which we should use.

* Rework port number magic
   Instead of requiring each player to use the correct port number for
   outgoing connections, we could let player 1 act as a coordinator.
   This one player would be required to listen on a well-known port,
   but the other players would not -- they simply listen to some port
   chosen by the OS and announce that to player 1, which in turn let
   the other players know.

   When everybody has been informed of everybody elses presence, the
   protocol execution can begin as normal with pair-wise connections
   between the players. So the coordinator is only used in a setup
   phase and wont become a bottleneck later.

Benchmarking
------------

* Use GMPY per default
   Make field elements use GMPY unless some option asks them not to.

* Benchmark Python vs. GMPY on different key sizes
   Initial tests seems to indicate that the network is the
   bottle-neck, but this should be systematically checked.

* Benchmark constant round multiplication
   The constant round multiplication protocol of Bar-Ilan and Beaver
   from PODC 1989 should be implemented and tested against a standard
   logarithmic round protocol.

Things we might eventually do
-----------------------------

* Lazy Shamir resharing
   After multiplying two shares, the result is a correct share of the
   product, but a share from a polynomial of degree 2t. We therefore
   normally reshare to get a polynomial of degree t.

   But for doing addition these degree 2t shares are fine, so we could
   wait with the resharing until it is surely needed.
 
   Let [a]_t denote a share of a using a degree t polynomial and let
   [a]_2t -> [a]_t denote a resharing going from degree 2t to t.

   We could then calculate

     sum([a_i]_t * [b_i]_t) = sum([a_i b_i]_2t)
                            = [sum(a_i b_i)]_2t -> [sum(a_i b_i)]_t

   using only one resharing at the end, saving network traffic. There
   does not seem to be many places where we do stuff like that,
   though. So the overhead of keeping track of when resharing is
   needed might be too big for this to be an improvement.


 LocalWords:  VIFF TODO Shamir GMPY wiki BuildBot Epydoc
